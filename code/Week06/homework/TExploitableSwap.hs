{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE NoImplicitPrelude  #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings  #-}
{-# LANGUAGE TemplateHaskell  #-}

module Main where

import           Control.Monad.IO.Class (liftIO)
import qualified ExploitableSwap      as OnChain
import           Control.Monad           (mapM, replicateM, unless)
import           Plutus.Model            (Ada (Lovelace), DatumMode (HashDatum, InlineDatum),
                                          Run, Tx,
                                          TypedValidator (TypedValidator),
                                          UserSpend, ada, adaValue,
                                          defaultBabbage, initMock, mustFail,
                                          newUser, payToKey, payToScript,
                                          runMock, spend, spendScript, submitTx,
                                          toV2, userSpend, utxoAt, valueAt, waitUntil, currentTimeRad, validateIn,
                                          FakeCoin (FakeCoin), fakeValue, testNoErrors, logError, logInfo, fakeCoin, sendTx, nftAt, txBoxValue)
import           Plutus.V2.Ledger.Api    (PubKeyHash, TxOut (txOutValue),
                                          TxOutRef, Value, POSIXTime (POSIXTime, getPOSIXTime))
import           Plutus.V1.Ledger.Value (geq)
import           PlutusTx.Builtins       (Integer, mkI)
import           PlutusTx.Prelude        (Bool (..), Eq ((==)),
                                          return, ($), (&&), (.))
import           Prelude                 (IO, Ord ((<), (>)),
                                          mconcat, (<>), undefined, show, Either (..), length, (>=), print)
import           Test.QuickCheck         (Property, Testable (property),
                                          collect, (==>), Arbitrary (arbitrary), choose)
import           Test.QuickCheck.Monadic (assert, monadic, run)
import           Test.Tasty              (defaultMain, testGroup)
import           Test.Tasty.QuickCheck   as QC (testProperty)

-- import           Plutus.Model         (Run,
--                                        TypedValidator (TypedValidator),
--                                        adaValue, defaultBabbage, mustFail, testNoErrors,
--                                        toV2, FakeCoin (FakeCoin), fakeValue)
-- import           PlutusTx.Prelude     (($))
-- import           Prelude              (IO, (.), (<>), undefined)
-- import qualified ExploitableSwap      as OnChain
-- import           Test.Tasty           (defaultMain, testGroup)

---------------------------------------------------------------------------------------------------
------------------------------------------ TESTING ------------------------------------------------

main :: IO ()
main = do
  defaultMain $ do
    testGroup
      "Catch double spend with testing"
      [ good "Normal spending" $ normalSpending 100
      , bad  "Double spending" $ doubleSpending 150
      ]
 where
    bad msg = good msg.mustFail
    good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage

---------------------------------------------------------------------------------------------------
----------------------------- HELPER FUNCTIONS/INSTANCES/TYPES ------------------------------------

scToken :: FakeCoin
scToken = FakeCoin "Super-Cool-Token"
 
type HomeworkScript = TypedValidator OnChain.DatumSwap ()

swapScript :: HomeworkScript
swapScript = TypedValidator $ toV2 OnChain.validator

-- temps d'attente
waitBeforeConsumingTx :: POSIXTime
waitBeforeConsumingTx = 1000

-- j'ai besoin d'un beneficiare 
setupUsers :: Run [PubKeyHash]
setupUsers = replicateM 2 $ newUser $ ada (Lovelace 1000)

-- mon script 
valScript :: TypedValidator datum redeemer
valScript = TypedValidator $ toV2 OnChain.validator

-- j'ai besoin d'un beneficiare pour mettre dans le utxo a mettre dans le script 
-- la fonction poour avoir le hash d'un user tourne dans la monad eRun, raison pour laquelle je sors un Run Tx
--lockingTx :: PubKeyHash -> Integer -> UserSpend -> Value -> Tx

-- userSpend c'est pour specifier la quantite d'argent que celui qui fait la tx va depenser
-- rmq : avec le mode hashDatum j'obtient une erreur : missing datumHash
lockingTx :: PubKeyHash -> Integer -> UserSpend -> Value -> Tx
lockingTx  vendeur prixDuNft usp val = 
  mconcat 
      [ userSpend usp
    , payToScript valScript (InlineDatum (OnChain.DatumSwap vendeur prixDuNft)) val
      ]


-- pour consommer je n'ai pas besoin de redeemer 
-- l'elemeent de type Value est la somme a payer au beneficiaire 
consumingTx :: PubKeyHash -> PubKeyHash -> Integer -> () -> TxOutRef -> Value -> Tx
consumingTx vendeur acheteur  nouvelleValeurNft redeemer  ref ancienneValeurDuNft =
   mconcat
    [ spendScript valScript ref (redeemer) (OnChain.DatumSwap acheteur nouvelleValeurNft)
    , payToKey vendeur ancienneValeurDuNft
    ]

-- la logique du doubleConsumingTx est a revoir 

doubleConsumingTx :: PubKeyHash -> PubKeyHash -> Integer -> () -> TxOutRef -> Value -> Tx
doubleConsumingTx  vendeur acheteur nouveauPrixNft redeemer (ref) ancienPrixDuNft = 
    mconcat [spendScript valScript ref (redeemer) (OnChain.DatumSwap acheteur nouveauPrixNft)
            , payToKey vendeur ancienPrixDuNft
            ] 
 

---------------------------------------------------------------------------------------------------
-------------------------------------- TESTING SPENDING -------------------------------------------

-- le nft est deja dans l'etat initial de la blockchain 

normalSpending :: Integer -> Run ()
normalSpending valeurDuNFT = do 
  [vendeur, acheteur] <- setupUsers
  -- ce que le vendeur depense pour la tx de lockingTx
  let valueToSpend = adaValue valeurDuNFT
  -- valeur pour proteger la tx surement un collateral
      protectionTxValue = adaValue 100
  sp <- spend vendeur valueToSpend 
  -- le vendeur fait une tx vers le script en mettant dedans un datum qui dit que c'est lui le beneficiaire et le prix de son nft
  submitTx vendeur $ lockingTx vendeur valeurDuNFT sp protectionTxValue
  -- on attend un peu avant query la blockchain
  waitUntil waitBeforeConsumingTx
  --il y a seulement un utxo dans le script : celui qu'on vient d'envoyer 
  utxos <- utxoAt valScript  
  --logError $ mconcat (mapM show utxos)             -- Query blockchain to get all UTxOs at script
  let [(ref, out)]       = utxos           -- We know there is only one UTXO (the one we created before)
  -- je cherche la valeur du utxo qui est dans le script 
      valeurDuUtxoSortie = txOutValue out 
  -- j'effectue la tx pour consommer le nft du script et puis payer le prix a la personne qui vend le nft en mettant un nouveau datum contenant moi comme beneficiare avec un prix
      txDeConsommation   = consumingTx vendeur acheteur 100 () ref valeurDuUtxoSortie
  submitTx acheteur txDeConsommation                           
 -- pour savoir la valeur de l'acheteur il faudrait qu'un nouveau client achete son nft, c'est pour cela que la condition se limite au premier vendeur.
 -- en mettant les deux conditions comme suit ca echoue, car la valeur du utxo de acheteur depend du futur
    --[v1, v2] <- mapM valueAt [vendeur, acheteur]                    
    -- unless (v1 == adaValue 1000 && v2 == adaValue 900) $  
  v1 <- valueAt vendeur 
  unless (v1 == adaValue 1000) $ 
    logError "Final balances are incorrect"
  --testNoErrorsTrace [(ref, out)])



{- voici le principe de doubleSpending : user cree deux nft, et les envois au script-}

doubleSpending :: Integer -> Run ()
doubleSpending prixDuNft = do 
  -- je cree un vendeur et un acheteur 
  [vendeur, acheteur] <- setupUsers
  let valueToSpend = adaValue prixDuNft
      txProtector    = adaValue 100
 -- je cree deux valeurs a spend par user1
  sp <- spend vendeur valueToSpend
 -- le vendeur cree deux nft et envoie au script : j'appelle deux fois ma lockingTx avec un temps de latence
  let firstTx = lockingTx vendeur prixDuNft sp txProtector
  submitTx vendeur firstTx
  waitUntil waitBeforeConsumingTx 
  let anotherFirstTx = lockingTx vendeur prixDuNft sp txProtector   -- on ne peut pas soumettre deux tx a la suite, il faut marquer un temps d'arret
  submitTx vendeur anotherFirstTx

   -- l'acheteur doit essayer de consommer deux nft en payant le prix pour un seul.
      -- la verification du doubleSpending peut s'effectuer a deux niveaux : 
      -- au moment ou il construit la tx : si il paye pour un nft alors il ne doit pas y avoir plus d'un nft en entree de la tx
      -- ou bien on verifie que si il paye pour nun nft peut import l'entree, en sortie il doit avoir juste un nft.
   -- je recupere les utxos dans le script 
  waitUntil waitBeforeConsumingTx   -- il faut attendre un peu avant de recuperer les utxos dans le scipt si non il y aura error : non-exhaustive patterns
  utxos <-  utxoAt valScript
  --liftIO $ print utxos
  -- **logInfo** (mconcat (mapM show utxos))
  -- les nfts ont le meme prix donc, j'ai pas besoin de trimbaler trop de donness
  let [(ref1, out1), (ref2,out2)]  =  utxos
      x:y:reste                    =  utxos
      valNft1                      = txOutValue out1
      --valNft2                      = txOutValue out2
      -- je ne peux pas construire un tx en appelant ma fonction consumingTx car il me faudrait passer la liste des TxOutRef
      tx = doubleConsumingTx vendeur acheteur 100 () ref1 valNft1
  submitTx acheteur tx 
   -- je verifie l'argent du vendeur
   -- l'argent de l'acheteur depend du futur
  v1 <-  valueAt vendeur
  unless (v1 == adaValue 900 ) $
     logError "tu as paye pour un seul nft seulement"
